Mark J. Price C# 10 and NET 6

https://github.com/markjprice/cs10dotnet6

https://github.com/markjprice/cs9dotnet5-extras/blob/main/raspberry-pi-ubuntu64/README.md


Types & Variables

• Literal string:
  Characters enclosed in double-quote characters. They can use escape characters like 	 for tab. To represent a backslash, use two: .

• Verbatim string:
  A literal string prefixed with @ to disable escape characters so that a backslash is a backslash. It also allows the string value to span
  multiple lines because the white space characters are treated as themselves instead of instructions to the compiler.

• Interpolated string:
  A literal string prefixed with $ to enable embedded formatted variables. You will learn more about this later in this chapter.

Examples:
  char x = 'a';
  string y = "abcdef"; string fullNameWithTabSeparator = "Bob	Smith";
  string filePath = @"C:	elevisionssonyravia.txt";
  string multiline = $"The variable {nameof(heightInMetres)} has the value {heightInMetres}."

Numbers
  // unsigned integer means positive whole number or 0
  uint naturalNumber = 23;
  
  // integer means negative or positive whole number or 0
  int integerNumber = -23;

  // float means single-precision floating point (F suffix makes it a float literal)
  float realNumber = 2.3F;

  // double means double-precision floating point
  double anotherRealNumber = 2.3; // double literal

  // Improving legibility
  uint x = 1_000_000;
  unint indianY = 10_00_000; // use the 2/3 grouping common in India

  // three variables that store the number 2 million
  int decimalNotation = 2_000_000;
  int binaryNotation = 0b_0001_1110_1000_0100_1000_0000;
  int hexadecimalNotation = 0x_001E_8480;

  Console.WriteLine("Using doubles:");
  double a = 0.1;
  double b = 0.2;

  if (a + b == 0.3)
  {
    Console.WriteLine($"{a} + {b} equals {0.3}");
  }
  else
  {
    Console.WriteLine($"{a} + {b} does NOT equal {0.3}");
  }

  Output:
    Using doubles:
    0.1 + 0.2 does NOT equal 0.3

  decimal c = 0.1M; // M suffix means a decimal literal value
  decimal d = 0.2M;

  if (c + d == 0.3M)
  {
    Console.WriteLine($"{c} + {d} equals {0.3M}");
  }
  else
  {
    Console.WriteLine($"{c} + {d} does NOT equal {0.3M}");
  }

  Output:
    Using decimals:
    0.1 + 0.2 equals 0.3

  Good Practice: Never compare double values using ==. During the First
  Gulf War, an American Patriot missile battery used double values in its
  calculations. The inaccuracy caused it to fail to track and intercept an incoming
  Iraqi Scud missile, and 28 soldiers were killed; you can read about this at
  https://www.ima.umn.edu/~arnold/disasters/patriot.html.

  Inferring types of variables
  
  • L: infers long
  • UL: infers ulong
  • M: infers decimal
  • D: infers double
  • F: infers float

  var x = 0.16M;
  var y = 0.0.16D;

Target Types
  XmlDocument xml3 = new(); // target-typed new in C# 9 or later

  class Person
  {
    public DateTime BirthDate;
  }

  Person kim = new();
  kim.BirthDate = new(1967, 12, 26); // instead of: new DateTime(1967, 12, 26)

Default value for types

  Console.WriteLine($"default(int) = {default(int)}");
  Console.WriteLine($"default(bool) = {default(bool)}");
  Console.WriteLine($"default(DateTime) = {default(DateTime)}");
  Console.WriteLine($"default(string) = {default(string)}");

  Output:
    default(int) = 0
    default(bool) = False
    default(DateTime) = 01/01/0001 00:00:00
    default(string) =

Arrays
  string[] names; // can reference any size array of strings

  names = new string[4]; // allocating memory for four strings in an array
  
  // OR
  string[] names2 = new[] { "Kate", "Jack", "Rebecca", "Tom" };
  
  // storing items at index positions
  names[0] = "Kate";
  names[1] = "Jack";
  names[2] = "Rebecca";
  names[3] = "Tom";

  // looping through the names
  for (int i = 0; i < names.Length; i++)
  {
   Console.WriteLine(names[i]);  // output the item at index position i
  }

Memory
  Stack
    Faster -> CPU -> Last-In -> First Out -> L1 and L2 -> Limited size
    Value Type -> record struct, struct

  Heap
    Slower -> More plentiful
    Reference Types -> record, class

Structure Types
  Number: byte, sbyte, short, ushort, int, unint, long, ulong, float, double, decimal
  Other: char, DateTime, bool
  Drawing: Color, Point, Rectangle


Finalizer

  public class Animal
  {
    public Animal() // constructor
    {
      // allocate any unmanaged resources
    }

    ~Animal() // Finalizer aka destructor
    {
      // deallocate any unmanaged resources
    }
  }

  public class Animal : IDisposable
  {

    public Animal()
    {
      // allocate unmanaged resource
    }

    ~Animal() // Finalizer
    {
      Dispose(false);
    }

    bool disposed = false; // have resources been released?

    public void Dispose()
    {
      Dispose(true);

      // tell garbage collector it does not need to call the finalizer
      GC.SuppressFinalize(this);
    }

    protected virtual void Dispose(bool disposing)
    {
      if (disposed) return;
      
      // deallocate the *unmanaged* resource
      // ...
      if (disposing)
      {
        // deallocate any other *managed* resources
        // ...
      }

      disposed = true;
    }
  }


  using (Animal a = new())
  {
    // code that uses the Animal instance
  }







Literal string:
  Characters enclosed in double-quote characters. They can use escape characters like \t for tab. To represent a backslash, use two: \\.
Verbatim string:
  A literal string prefixed with @ to disable escape characters so that a backslash is a backslash. It also allows the string value to span multiple lines because the white space characters are treated as themselves instead of instructions to the compiler.

Interpolated string:
  A literal string prefixed with $ to enable embedded formatted variables. You will learn more about this later in this chapter.

Good Practice:
  Never compare double values using ==.
  During the First Gulf War, an American Patriot missile battery used double values in its calculations. The inaccuracy caused it to fail to track and intercept an incoming Iraqi Scud missile, and 28 soldiers were killed; you can read about this at https://www.ima.umn.edu/~arnold/disasters/patriot.html.

Good Practice:
  Use int for whole numbers.
  Use double for real numbers that will not be compared for equality to other values; it is okay to compare double values being less than or greater than, and so on.
  Use decimal for money, CAD drawings, general engineering, and wherever the accuracy of a real number is important.

Numbers
  L: infers long
  UL: infers ulong
  M: infers decimal
  D: infers double
  F: infers float

This style of if statement should be avoided because it can introduce serious bugs, for example, the infamous #gotofail bug in Apple's iPhone iOS operating system.

For 18 months after Apple's iOS 6 was released, in September 2012, it had a bug in its Secure Sockets Layer (SSL) encryption code, which meant that any user running Safari, the device's web browser, who tried to connect to secure websites, such as their bank, was not properly secure because an important check was being accidentally skipped.

Just because you can leave out the curly braces doesn't mean you should. Your code is not "more efficient" without them; instead, it is less maintainable and potentially more dangerous.

--

This rule is known as Banker's Rounding, and it is preferred because it reduces bias by alternating when it rounds up or down. Sadly, other languages such as JavaScript use the primary school rule.

It always rounds down if the decimal part is less than the midpoint .5.
It always rounds up if the decimal part is more than the midpoint .5.
It will round up if the decimal part is the midpoint .5 and the non-decimal part is odd, but it will round down if the non-decimal part is even.

--

The safest thing to do is to convert the binary object into a string of safe characters. Programmers call this Base64 encoding.

When a parameter is passed into a method, it can be passed in one of three ways:

By value (this is the default): Think of these as being in-only.
By reference as a ref parameter: Think of these as being in-and-out.
As an out parameter: Think of these as being out-only.

When passing a variable as a parameter by default, its current value gets passed, not the variable itself. Therefore, x has a copy of the value of the a variable. The a variable retains its original value of 10.
When passing a variable as a ref parameter, a reference to the variable gets passed into the method. Therefore, y is a reference to b. The b variable gets incremented when the y parameter gets incremented.
When passing a variable as an out parameter, a reference to the variable gets passed into the method. Therefore, z is a reference to c. The value of the c variable gets replaced by whatever code executes inside the method. We could simplify the code in the Main method by not assigning the value 30 to the c variable since it will always be replaced anyway.

--

There are two categories of memory: stack memory and heap memory. With modern operating systems, the stack and heap can be anywhere in physical or virtual memory.

Stack memory is faster to work with (because it is managed directly by the CPU and because it uses a last-in, first-out mechanism, it is more likely to have the data in its L1 or L2 cache) but limited in size, while heap memory is slower but much more plentiful.

--

These are the most common struct types:

Number System types: byte, sbyte, short, ushort, int, uint, long, ulong, float, double, and decimal

Other System types: char, DateTime, and bool

System.Drawing types: Color, Point, and Rectangle

Almost all the other types are class types, including string.

Apart from the difference in terms of where in memory the data for a type is stored, the other major difference is that you cannot inherit from a struct.

--

Good Practice: If the total bytes used by all the fields in your type is 16 bytes or less, your type only uses value types for its fields, and you will never want to derive from your type, then Microsoft recommends that you use struct. If your type uses more than 16 bytes of stack memory, if it uses reference types for its fields, or if you might want to inherit from it, then use class.

--

Releasing unmanaged resources

In the previous chapter, we saw that constructors can be used to initialize fields and that a type may have multiple constructors. Imagine that a constructor allocates an unmanaged resource; that is, anything that is not controlled by .NET, such as a file or mutex under the control of the operating system. The unmanaged resource must be manually released because .NET cannot do it for us using its automatic garbage collection feature.

--

There are two Dispose methods, one public and one protected:

    The public void Dispose method will be called by a developer using your type. When called, both unmanaged and managed resources need to be deallocated.
    The protected virtual void Dispose method with a bool parameter is used internally to implement the deallocation of resources. It needs to check the disposing parameter and disposed field because if the finalizer thread has already run and it called the ~Animal method, then only unmanaged resources need to be deallocated.

--

Enabling nullable and non-nullable reference types

To enable the feature at the project level, add the following to your project file:

<PropertyGroup>
  ...
  <Nullable>enable</Nullable>
</PropertyGroup>
CopyExplain

This is now done by default in project templates that target .NET 6.0.

To disable the feature at the file level, add the following to the top of a code file:

#nullable disable
CopyExplain

To enable the feature at the file level, add the following to the top of a code file:

#nullable enable

--

C# 7 introduced is combined with the ! (not) operator as an alternative to !=, as shown in the following code:

if (!(thisCouldBeNull is null))
{
CopyExplain

C# 9 introduced is not as an even clearer alternative, as shown in the following code:

if (thisCouldBeNull is not null)
{
CopyExplain

If you are trying to use a member of a variable that might be null, use the null-conditional operator ?., as shown in the following code:

string authorName = null;
// the following throws a NullReferenceException
int x = authorName.Length;
// instead of throwing an exception, null is assigned to y
int? y = authorName?.Length;
CopyExplain

Sometimes you want to either assign a variable to a result or use an alternative value, such as 3, if the variable is null. You do this using the null-coalescing operator, ??, as shown in the following code:

// result will be 3 if authorName?.Length is null 
int result = authorName?.Length ?? 3; 
Console.WriteLine(result);
CopyExplain

Good Practice: Even if you enable nullable reference types, you should still check non-nullable parameters for null and throw an ArgumentNullException.

--

Alternatively, you can use the as keyword to cast. Instead of throwing an exception, the as keyword returns null if the type cannot be cast.

--

Understanding common StyleCop recommendations

Inside a code file, you should order the contents, as shown in the following list:

    External alias directives
    Using directives
    Namespaces
    Delegates
    Enums
    Interfaces
    Structs
    Classes

Within a class, record, struct, or interface, you should order the contents, as shown in the following list:

    Fields
    Constructors
    Destructors (finalizers)
    Delegates
    Events
    Enums
    Interfaces
    Properties
    Indexers
    Methods
    Structs
    Nested classes and records

Good Practice: You can learn about all the StyleCop rules at the following link: https://github.com/DotNetAnalyzers/StyleCopAnalyzers/blob/master/DOCUMENTATION.md.

--

.NET Core 2.0 and later's support for a minimum of .NET Standard 2.0 is important because it provides many of the APIs that were missing from the first version of .NET Core. The 15 years' worth of libraries and applications that .NET Framework developers had available to them that are relevant for modern development have now been migrated to .NET and can run cross-platform on macOS and Linux variants, as well as on Windows.

.NET Standard 2.1 added about 3,000 new APIs. Some of those APIs need runtime changes that would break backward compatibility, so .NET Framework 4.8 only implements .NET Standard 2.0. .NET Core 3.0, Xamarin, Mono, and Unity implement .NET Standard 2.1.

.NET 6 removes the need for .NET Standard if all your projects can use .NET 6. Since you might still need to create class libraries for legacy .NET Framework projects or legacy Xamarin mobile apps, there is still a need to create .NET Standard 2.0 and 2.1 class libraries. In March 2021, I surveyed professional developers, and half still needed to create .NET Standard 2.0 compliant class libraries.

Now that .NET 6 has been released with preview support for mobile and desktop apps built using .NET MAUI, the need for .NET Standard has been further reduced.

NET Core 1.x: much smaller API compared to .NET Framework 4.6.1, which was the current version in March 2016.
.NET Core 2.x: reached API parity with .NET Framework 4.7.1 for modern APIs because they both implement .NET Standard 2.0.
.NET Core 3.x: larger API compared to .NET Framework for modern APIs because.NET Framework 4.8 does not implement .NET Standard 2.1.
.NET 5: even larger API compared to .NET Framework 4.8 for modern APIs, with much-improved performance.
.NET 6: final unification with the support for mobile apps in .NET MAUI, expected by May 2022.

--

.NET is made up of several pieces, which are shown in the following list:

Language compilers: These turn your source code written with languages such as C#, F#, and Visual Basic into intermediate language (IL) code stored in assemblies. With C# 6.0 and later, Microsoft switched to an open-source rewritten compiler known as Roslyn that is also used by Visual Basic.
Common Language Runtime (CoreCLR): This runtime loads assemblies, compiles the IL code stored in them into native code instructions for your computer's CPU, and executes the code within an environment that manages resources such as threads and memory.
Base Class Libraries (BCL or CoreFX): These are prebuilt assemblies of types packaged and distributed using NuGet for performing common tasks when building applications. You can use them to quickly build anything you want, rather like combining LEGO™ pieces. .NET Core 2.0 implemented .NET Standard 2.0, which is a superset of all previous versions of .NET Standard, and lifted .NET Core up to parity with .NET Framework and Xamarin. .NET Core 3.0 implemented .NET Standard 2.1, which added new capabilities and enables performance improvements beyond those available in .NET Framework. .NET 6 implements a unified BCL across all types of apps, including mobile.

--

Packages
  Packages can be easily distributed on public feeds.
  Packages can be reused.
  Packages can ship on their own schedule.
  Packages can be tested independently of other packages.
  Packages can support different OSes and CPUs by including multiple versions of the same assembly built for different OSes and CPUs.
  Packages can have dependencies specific to only one library.
  Apps are smaller because unreferenced packages aren't part of the distribution. The following table lists some of the more important packages and their important types:

  .NET packages each support a set of frameworks. For example, the System.IO.FileSystem package version 4.3.0 supports the following frameworks:
    .NET Standard, version 1.3 or later.
    .NET Framework, version 4.6 or later.
    Six Mono and Xamarin platforms (for example, Xamarin.iOS 1.0).
--

SDK               Default target framework for new class libraries
.NET Core 3.1     netstandard2.0
.NET 5            net5.0
.NET 6            net6.0

--

Class library target framework        Can be used by projects that target
netstandard2.0                        .NET Framework 4.6.1 or later, .NET Core 2.0 or later, .NET 5.0 or later, Mono 5.4 or later, Xamarin.Android 8.0 or later, Xamarin.iOS 10.14 or later
netstandard2.1                        .NET Core 3.0 or later, .NET 5.0 or later, Mono 6.4 or later, Xamarin.Android 10.0 or later, Xamarin.iOS 12.16 or later
net5.0                                .NET 5.0 or later
net6.0                                .NET 6.0 or later

--

Type                Product       Description         
Virtual Machine     VMware        Professionals like malware analysts always run software inside a VM.
Debugger            SoftICE       Runs underneath the operating system usually in a VM.
Debugger            WinDbg        Useful for understanding Windows internals because it knows more about Windows data structures than other debuggers.
Disassembler        IDA Pro       Used by professional malware analysts.
Decompiler          HexRays       Decompiles C apps. Plugin for IDA Pro.
Decompiler          DeDe          Decompiles Delphi apps.
Decompiler          dotPeek       .NET decompiler from JetBrains.

--

mumat.matcuer.unam.mx
redato
GEMA, ENI CONACHYT
renajeb


